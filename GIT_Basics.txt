START

Consult the video: https://www.youtube.com/watch?v=8JJ101D3knE
                https://www.youtube.com/watch?v=S7XpTAnSDL4
CONSULT THE DOCUMENTATION: https://git-scm.com/docs
or the cheatsheet: https://education.github.com/git-cheat-sheet-education.pdf

Commands:

- echo commands
    + "> [file_name]" -> Create a [file_name] (Remember to include .txt, .py, .ipynb, etc.)
    + ">> [Msg] [file_name]" -> Append [Msg] to file file_name

- git commands
There are 3 Stages, Work -> Stage -> Commit
    Use add to add file to Stage
    Use commit to add file FROM stage to Commit
        If you modify a file, Stage will contain THE OLD VERSION of the file you modified
            => If you commit, you will commit the OLD VERSION and not the new one you modified
            => You HAVE to add the modify file to the Stage to update init
        *If you remove a file, that file you deleted will STILL BE in Stage
        *To remove it, use git -add [that exact file] to Stage and it will delete it there

    + "-init" -> Add .git file, don't remove, if remove lose all history

    + "status" -> Red: Not In Stage | Green: In Stage
                    Check if everything is in Stage/Committed.
                    Check if files have been Modified or Deleted
        + "status -s" -> Red M on Right Side: modified in repo but that change not in staging area
                         Green M on Left Side: All the changes in repo is now in staging area
                         Green M on Left, Red M on Right: Changes in Staging Area, changes
                                                                    in repo but not added to staging area
                         Double Red ? (??): New file, not in Staging Area and newly added to repo
                         Green A on Left: Added to Staging Area
                        *Right Column/Side -> Working directory/repo
                        *Left Column/Side -> Staging Area
                        *M: Modified
                        *A: Added

    + "stage [file_name]" -> Add [file_name] to Stage
            (Literally add)

    + "add [file_name]" -> Add file_name to Stage
        "-add ." -> Add all files
        "-add *[file_type]" -> Add all files with type == [file_type]

    + "commit -m [commit_msg]" -> Add files to Commit with msg = [commit_msg]
        + "commit" -> Open the COMMIT_EDITMSG file, you can see the files in Stage and newly edited file
        + "commit -a" -> Commit all Files (No msg) | Skip Staging 
        + "commit -am [commit_msg]" -> Commit all Files (With msg) | Skip Staging

    + "mv [old_file_name] [new_file_name]" -> Change [old_file_name] to [new_file_name] (Staged)
                                                        (You can even change the type)
        * You have to commit the changes to stage first AND THEN change the file name
        * The [new_file_name] will be tracked IMMEDIATELY
        * If you renamed and don't commit, and then modify it, [old_file_name]
                                            will be created along with [new_file_name]

    + "ls-files" -> Files in the Staging Area
    
    + "rm [file1] [file2] [...]" -> Remove file from repo + staging Area
        + "rm *.[file_type]" -> Remove all file with type = [file_type] from working directory + staging Area
        + "rm ." -> Remove all files from repo + staging Area

    + "rm --cached [file_to_remove]" -> Only remove from staging area (or Index by oldheads)
        + "rm --cached -r [file_to_remove]" -> Only remove from staging area (recursive removal)
                * REMEMBER TO COMMIT THE REMOVE

    + "diff --staged" -> Showcase what we have in Staging Area that's going to commit (use visual tools instead)
                        comparing a/[file_name] to b/[file_name]: a means the old file, b means the new file
                         index: metadata
                         Changes in old file is indicated by - / minus sign 
                         Changes in new file is indicated by + / plus sign 
                         @@ @@ header: - / minus sign indicates old copy
                                        + / plus sign indicates new copy
                            Ex: -1, 3 -> Starting from 1st line, 3 Lines have been extracted (old file)
                                +1, 5 -> Starting frm 1st line, 5 Lines have been extracted (new file)
                         +[green_color] -> Added lines to the new copy
                         *If there are multiple files, after comparing 1st file, moves to 2nd
                         If you create a new file:
                            new file mode [id]
                            index: metadata
                            Since we create new file, there's NO old file
                                It will display --- /dev/null
                        @@ -0,0 +1@@ Starting from line 0, 0 lines have been extracted since there was no file
                                    One line has been added to the new file
            "diff" -> Comparing work dir to staging area
                            Same thing as diff --staged
                            -[red_color] -> This line has been changed
            "difftool" -> Visual Tool, open the difftool so we can see changes


                         

- Other Commands:
    + "ls" -> List all files in working directory

    + "rm [file_name]" -> Remove file_name

    + "mv [old_file_name] [new_file_name]" -> Change [old_file_name] to [new_file_name] (Unstaged)
            * The [new_file_name] will NOT be tracked so you gotta add it IMMEDIATELY to Staging
            * If you renamed and don't add, and then modify it, [old_file_name]
                                            will be created along with [new_file_name]
                => You gotta do git -add [old_file_name] to remove that old file
                        then do git -add [new_file_name] to start tracking the renamed file

    "mkdir [dir_name]" -> Create directory name [dir_name]

    "cd [dir_name]" -> Change directory to [dir_name]


---------
.gitignore:
    - Will ignore the files written in it (If you modify the file in gitignore,
                                                            git will ignore the modification)
            + Does not add to staging (even if use add all)
            + Does not commit them (even if use commit all)
        * If you add a file to staging area and commit it
        * If you THEN add that file to gitignore, it will still stay in the staging area
        * And ANY changes made to that file will count as a modification
                        -> Gotta add it to staging area and COMMIT IT.
                        -> We gotta delete it from the staging area

ALWAYS REVIEW WHAT U HAVE IN STAGING AREA B4 COMMIT